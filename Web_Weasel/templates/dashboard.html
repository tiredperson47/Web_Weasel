<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Weasel — Gobuster Mapper</title>

  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" />
  
  <style>
  body { font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin:0; background:#0f1724; color:#e6eef8; font-size:16px }
  header { display:flex; gap:1rem; align-items:center; padding:1rem; background:#071022 } 
    header a { color:#9bd0ff; text-decoration:none; font-weight:600 }
  .container { padding:1rem }
    .hidden { display:none }
    #network { width:100%; height:600px; background:#071022; border-radius:8px; box-shadow:0 6px 18px rgba(2,6,23,0.6); }
    body.light #network { background:#ffffff; box-shadow:0 2px 8px rgba(0,0,0,0.1) }
    .panel { background:#071022; padding:1rem; border-radius:8px; margin-bottom:1rem }
    label { display:block; margin-bottom:.25rem; color:#cfe8ff; font-size:15px }
  input, select, button, textarea { padding:.75rem; border-radius:8px; border:1px solid #15324a; background:#071722; color:#e6eef8; font-size:15px }
    textarea { width:100%; height:110px; resize:none; font-family:monospace; }
    #cypher-box { width:100%; height:140px; box-sizing:border-box; font-family:monospace; }
    input, select { width:100%; box-sizing:border-box }
    .row { display:flex; gap:.5rem; align-items:center }
    .small { font-size:.9rem; color:#9bbbd9 }
    /* Popup button styles and visual "clicking" effect */
    #add-node-popup button {
      transition: all 160ms ease;
    }
    #popup-submit {
      background:#9bd0ff;
      color:#071022;
      border:none;
      padding:.5rem .75rem;
      border-radius:6px;
      cursor:pointer;
    }
    /* Visually show that the Add button is in progress */
    #popup-submit.adding {
      transform: translateY(1px) scale(0.995);
      background: linear-gradient(90deg,#7fc3ff,#bde8ff);
      box-shadow: 0 4px 10px rgba(0,0,0,0.25) inset;
      opacity: 0.95;
    }
    /* Short success pulse */
    #popup-submit.success {
      background: linear-gradient(90deg,#8ef08a,#5de86a);
      color: #042014;
      transform: translateY(0) scale(1.02);
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    /* Light mode overrides */
    body.light { background: #f8fafc; color: #071022 }
    body.light header { background: #ffffff; color: #071022 }
    body.light .panel { background: #ffffff; color: #071022; border: 1px solid #e2e8f0 }
    body.light input, body.light select, body.light textarea { background:#ffffff; color:#071022; border:1px solid #cbd5e1 }
    /* Light mode for vis.js nodes */
    body.light .vis-network .vis-label { color: #071022 !important; }
    body.light .vis-network .vis-edge-label { color: #071022 !important; }

    /* Button click effect */
    button { transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms }
    button:active { transform: translateY(2px) scale(0.995); box-shadow: inset 0 2px 6px rgba(0,0,0,0.15) }
  </style>
</head>

<body>

<header>
  <h3 style="margin:0">Web Weasel — Graph Dashboard</h3>
  <nav style="margin-left:1rem">
    <a href="#" id="nav-dashboard">Dashboard</a> |
    <a href="#" id="nav-upload">Upload</a> |
    <a href="#" id="nav-tasks">Tasks</a> |
    <a href="/manage-operators" id="nav-manage">Manage Operators</a>
  </nav>

  <div style="margin-left:auto; display:flex; gap:.5rem; align-items:center">
  <button id="btn-export" title="Export graph JSON">Export</button>
  <button id="toggle-theme">Light Mode</button>
    <a href="/logout" style="color:#9bd0ff">Logout</a>
  </div>
</header>

<main class="container">

<!-- ========================= DASHBOARD ========================= -->
<section id="page-dashboard">

  <!-- BLOODHOUND-LIKE QUERY BAR -->
  <div class="panel" style="display:flex; gap:1rem; align-items:flex-start">
    <div style="flex:1">
      <label><strong>Cypher Query</strong></label>
      <textarea id="cypher-box" placeholder="Write or modify your Cypher query here..."></textarea>
    </div>
    <div style="width:320px">
      <label><strong>Presets / Run</strong></label>
      <select id="preset-queries" style="width:100%">
        <option value="">Select a predefined query...</option>
        <option value="MATCH (n)-[r]->(m) RETURN n,r,m LIMIT 200">Full Graph (Limit 200)</option>
        <option value="MATCH (d:Domain {name: $domain}) OPTIONAL MATCH (d)-[r*0..]->(p) RETURN d,r,p LIMIT 500">All Paths Under Domain (recursive)</option>
        <option value="MATCH (s:Subdomain {host: $subdomain}) OPTIONAL MATCH (s)-[r*1..]->(p) RETURN s,r,p LIMIT 500">All Paths Under Subdomain (recursive)</option>
        <option value="MATCH (p:Path {domain: $domain, path: $path}) OPTIONAL MATCH (p)-[r*0..]->(c) RETURN p,r,c">Filter by Path (recursive)</option>
      </select>
      <div style="display:flex; gap:.5rem; margin-top:.5rem;">
        <button id="btn-run-query">Run Query</button>
        <button id="btn-fit">Fit Graph</button>
      </div>
    </div>
  </div>

  <!-- PARAMETER FILTERS (Bloodhound style) -->
  <div class="panel">
    <div class="row">
      <div style="flex:1">
        <label>Filter by Domain</label>
        <input id="param-domain" placeholder="example.com" />
      </div>

      <div style="flex:1">
        <label>Filter by Subdomain</label>
        <input id="param-subdomain" placeholder="www.example.com" />
      </div>

      <div style="flex:1">
        <label>Filter by Path</label>
        <input id="param-path" placeholder="/admin/login" />
      </div>
    </div>
  </div>

  <!-- GRAPH -->
  <div style="display:flex; gap:1rem">
    <div id="network" style="flex:1"></div>
    <div id="side-panel" class="panel" style="width:360px; max-height:600px; overflow:auto;">
      <strong>Selected Node</strong>
      <div id="selection-info" class="small">Click a node to see details</div>

      <hr style="border-color:#123248" />
      <div>
        <label>Node Data</label>
        <div id="node-data"></div>
      </div>

      <hr style="border-color:#123248" />
      <div>
        <label>Notes</label>
        <textarea id="node-notes" placeholder="Shared notes for this node"></textarea>
        <div style="display:flex; gap:.5rem; justify-content:flex-end; margin-top:.5rem">
          <button id="btn-save-notes">Save</button>
        </div>
      </div>
    </div>
  </div>

  <!-- NODE DETAILS (moved to side-panel) -->

</section>


<!-- ========================= UPLOAD ========================= -->
<section id="page-upload" class="hidden">
  <div class="panel">
    <form id="upload-form">
      <label for="url">Scanned URL</label>
      <input id="url" name="url" placeholder="example.com" required />

      <label for="files">Gobuster output files</label>
      <input id="files" name="file" type="file" multiple required />

      <div class="row">
        <button id="upload-submit" type="submit">Upload & Parse</button>
        <button type="button" id="btn-upload-reset">Reset</button>
      </div>

      <div class="upload-feedback" id="upload-feedback" style="white-space:pre-wrap;font-family:monospace;color:#bfefff"></div>
    </form>
  </div>
</section>

<!-- ========================= TASKS ========================= -->
<section id="page-tasks" class="hidden">
  <div class="panel" style="max-width:100%; padding:1rem;">
    <h2>Tasks</h2>
    <p style="margin-bottom:1rem;">Check off endpoints as you scan them. Data is persisted across sessions.</p>
    
    <!-- Operator dropdowns section -->
    <div id="operators-container" style="margin-bottom:2rem;">
      <h3>Operator Tasks</h3>
      <div id="operators-list" style="display:flex; flex-direction:column; gap:1rem;">
        <!-- Operators will be dynamically loaded here -->
      </div>
    </div>

    <!-- All unchecked section -->
    <div id="all-container" style="margin-bottom:2rem;">
      <h3>Globally Unchecked</h3>
      <button id="btn-expand-all" style="margin-bottom:1rem;">Expand All Unchecked</button>
      <div id="all-list" style="display:flex; flex-direction:column; gap:0.5rem; max-height:400px; overflow-y:auto;">
        <!-- Endpoints will be populated here -->
      </div>
    </div>
  </div>
</section>

</main>

<!-- ===================== ADD NODE POPUP ===================== -->
<div id="add-node-popup" class="hidden" style="
    position: fixed;
    top:50%; left:50%;
    transform: translate(-50%, -50%);
    background: #071022;
    border: 1px solid #1f3b5a;
    padding: 1rem 1.5rem;
    border-radius: 8px;
    z-index: 10000;
    box-shadow: 0 6px 18px rgba(2,6,23,0.6);
    width: 300px;
">
  <h3 style="margin-top:0; color:#9bd0ff; font-size:1.1rem">Add Node</h3>

  <label style="margin-top:.5rem">Node Type</label>
  <div class="row" style="margin-bottom:.5rem">
    <button class="parent-type-btn" data-type="subdomain">Subdomain</button>
    <button class="parent-type-btn" data-type="path">Path</button>
  </div>

  <label id="label-field1">Primary Field</label>
  <input id="popup-path" placeholder="primary" />

  <label id="label-field2">Secondary Field</label>
  <input id="popup-domain" placeholder="secondary" />

  <div class="row" style="justify-content:flex-end; margin-top:0.75rem;">
    <button id="popup-cancel" style="background:#112034; border:1px solid #15324a;">Cancel</button>
    <button id="popup-submit" style="background:#9bd0ff; color:#071022; border:none;">Add</button>
  </div>
</div>

<script>
// ===== Popup Logic =====
const popup = document.getElementById("add-node-popup");
let selectedParentType = null;

// Style buttons and handle selection
document.querySelectorAll(".parent-type-btn").forEach(btn => {
  btn.style.flex = "1";
  btn.style.padding = ".5rem";
  btn.style.borderRadius = "6px";
  btn.style.border = "1px solid #15324a";
  btn.style.background = "#071722";
  btn.style.color = "#e6eef8";
  btn.style.cursor = "pointer";

  btn.onmouseenter = () => btn.style.background = "#112034";
  btn.onmouseleave = () => {
    if(selectedParentType !== btn.dataset.type) btn.style.background = "#071722";
  };

  btn.onclick = () => {
    selectedParentType = btn.dataset.type;
    document.querySelectorAll(".parent-type-btn").forEach(b => b.style.background="#071722");
    btn.style.background = "#1f3b5a";
    
    // Update labels based on selected type
    const label1 = document.getElementById("label-field1");
    const label2 = document.getElementById("label-field2");
    const field1 = document.getElementById("popup-path");
    const field2 = document.getElementById("popup-domain");
    
    if(selectedParentType === 'subdomain'){
      label1.textContent = "Subdomain Host";
      label2.textContent = "Base Domain";
      field1.placeholder = "s3.example.com";
      field2.placeholder = "example.com";
      field2.disabled = false;
    } else if(selectedParentType === 'path'){
      label1.textContent = "Path";
      label2.textContent = "Domain";
      field1.placeholder = "/admin/users";
      field2.placeholder = "example.com";
      field2.disabled = false;
    }
  };
});

// Open the popup (example trigger)
function openAddNodePopup() {
  selectedParentType = null;
  document.querySelectorAll(".parent-type-btn").forEach(b => b.style.background="#071722");
  document.getElementById("popup-path").value = "";
  document.getElementById("popup-domain").value = "";
  popup.classList.remove("hidden");
  popup.onclick = (e) => e.stopPropagation();
}

// Optional: close popup by clicking outside
window.addEventListener("click", (e) => {
  if (e.button === 0) { // left click
    if (!popup.contains(e.target) && !popup.classList.contains("hidden")) {
      popup.classList.add("hidden");
    }
  }
});

/* ===================== NAV SPA ===================== */
const pageDashboard = document.getElementById("page-dashboard");
const pageUpload = document.getElementById("page-upload");
const pageTasks = document.getElementById("page-tasks");

document.getElementById("nav-dashboard").onclick = (e)=>{
  e.preventDefault(); pageDashboard.classList.remove("hidden"); pageUpload.classList.add("hidden"); pageTasks.classList.add("hidden");
};
document.getElementById("nav-upload").onclick = (e)=>{
  e.preventDefault(); pageUpload.classList.remove("hidden"); pageDashboard.classList.add("hidden"); pageTasks.classList.add("hidden");
};
document.getElementById("nav-tasks").onclick = (e)=>{
  e.preventDefault(); pageTasks.classList.remove("hidden"); pageDashboard.classList.add("hidden"); pageUpload.classList.add("hidden"); loadTasksTab();
};


/* ===================== VIS GRAPH ===================== */
const container = document.getElementById("network");
let network = null;
const nodes = new vis.DataSet([]);
const edges = new vis.DataSet([]);

const options = {
  nodes: { shape:"dot", size:18, font:{color:"#e6eef8"} },
  edges: { arrows:{to:{enabled:true}}, font:{color:"#7aa7d7", strokeWidth:0, size:14} },
  physics: { stabilization: true },
  interaction: {
    multiselect: true,
    selectable: true,
  }
};

function renderGraph(data){
  nodes.clear(); edges.clear();
  nodes.add(data.nodes); edges.add(data.edges);
  
  // Check each node for vuln property and update label if needed
  data.nodes.forEach(nodeData => {
    updateNodeLabelForVulnerability(nodeData, nodeData.id);
  });

  if(!network){
    network = new vis.Network(container, { nodes, edges }, options);

    network.on("click", (params)=>{
      if(params.nodes.length){
        const node = nodes.get(params.nodes[0]);
        document.getElementById("selection-info").textContent = JSON.stringify(node, null, 2);
      }
    });

    /* ---------------------- RIGHT CLICK MENU ---------------------- */
    network.on("oncontext", (params)=>{
      params.event.preventDefault();

      const pointer = params.pointer.DOM;
      const nodeId = params.nodes[0] || null;
      const edgeId = network.getEdgeAt(pointer);

      showContextMenu(params.event.pageX, params.event.pageY, nodeId, edgeId);
    });

  } else {
    network.setData({ nodes, edges });
  }
}


/* ===================== CONTEXT MENU ===================== */
const menu = document.createElement("div");
menu.style.position = "absolute";
menu.style.background = "#0b1624";
menu.style.border = "1px solid #1f3b5a";
menu.style.padding = "8px";
menu.style.borderRadius = "6px";
menu.style.display = "none";
menu.style.zIndex = "9999";
document.body.appendChild(menu);

function showContextMenu(x, y, nodeId, edgeId){
  menu.innerHTML = "";

  if(nodeId){
    addMenuItem("Delete Node",
      () => {
        try {
          executeCypherQuery(`MATCH (n) WHERE elementId(n) = "${nodeId}" DETACH DELETE n`);
          nodes.remove(nodeId);
        } catch (err) {
          console.error('Delete node error:', err);
          alert('Error deleting node: ' + err.message);
        }
      });

    addMenuItem("Delete Children",
      () => {
        try {
          executeCypherQuery(`
            MATCH (n) WHERE elementId(n) = "${nodeId}"
            MATCH (n)-[*1..]->(c)
            DETACH DELETE c
          `);
          const childIds = getDescendants(nodeId).filter(id => id !== nodeId);
          nodes.remove(childIds);
          // Remove edges connected to deleted nodes
          edges.forEach(edge => {
            if (childIds.includes(edge.from) || childIds.includes(edge.to)) {
              edges.remove(edge.id);
            }
          });
        } catch (err) {
          console.error('Delete children error:', err);
          alert('Error deleting children: ' + err.message);
        }
      });

    addMenuItem("Delete Node + Children",
      () => {
        try {
          executeCypherQuery(`
            MATCH (n) WHERE elementId(n) = "${nodeId}"
            MATCH (n)-[*0..]->(c)
            DETACH DELETE c
          `);
          const allIds = getDescendants(nodeId);
          nodes.remove(allIds);
          // Remove edges too
          edges.forEach(edge => {
            if (allIds.includes(edge.from) || allIds.includes(edge.to)) {
              edges.remove(edge.id);
            }
          });
        } catch (err) {
          console.error('Delete node+children error:', err);
          alert('Error deleting node and children: ' + err.message);
        }
      });

    addMenuItem("Add Child Node", () => {
      openAddNodePopup();

      const submitBtn = document.getElementById("popup-submit");
      const cancelBtn = document.getElementById("popup-cancel");

      // Remove previous click listeners to prevent stacking
      const newSubmit = submitBtn.cloneNode(true);
      const newCancel = cancelBtn.cloneNode(true);
      submitBtn.parentNode.replaceChild(newSubmit, submitBtn);
      cancelBtn.parentNode.replaceChild(newCancel, cancelBtn);

      newCancel.onclick = async () => {
        popup.classList.add("hidden");
      }

      newSubmit.onclick = async () => {
        const field1 = document.getElementById("popup-path").value.trim();
        const field2 = document.getElementById("popup-domain").value.trim();

        if (!selectedParentType) return alert("Select a node type!");
        
        const type = selectedParentType.charAt(0).toUpperCase() + selectedParentType.slice(1);
        let cypher = "";
        let params = {};
        let domain = null;

        try {
          if (type === 'Subdomain'){
            // For subdomain: field1 = subdomain host (s3.example.com), field2 = base domain (example.com)
            if (!field1 || !field2) return alert("Enter both subdomain host and base domain!");
            domain = field2;
            const subdomainHost = field1;
            cypher = `
              MERGE (bd:Domain {name: $domain})
              MERGE (s:Subdomain {host: $subdomainHost})
              SET s.domain = $domain
              MERGE (bd)-[:Subdomain]->(s)
              RETURN elementId(s) AS id, s
            `;
            params = { domain, subdomainHost };
          } else if (type === 'Path'){
            // For path: field1 = path (/admin), field2 = domain
            if (!field1 || !field2) return alert("Enter both path and domain!");
            domain = field2;
            const path = field1;
            cypher = `
              MATCH (n) WHERE elementId(n) = $nodeId
              CREATE (p:Path {domain: $domain, path: $path})
              CREATE (n)-[:Subdirectory]->(p)
              RETURN elementId(p) AS id, p
            `;
            params = { nodeId, domain, path };
          }

          const res = await executeCypherQuery(cypher, params);
          
          const rec = res.records[0];
          let newNodeId = null;
          for(const key in rec){
            const val = rec[key];
            if(val && typeof val === 'object' && val._type === 'node'){
              newNodeId = val.element_id;
              break;
            }
          }
          
          if(!newNodeId){
            alert('Could not extract node ID from response');
            return;
          }
          
          // Success! Add the node to the graph
          nodes.add({ id: newNodeId, label: field1 || field2, group: type, domain });
          if(nodeId) edges.add({ from: nodeId, to: newNodeId, label: 'Subdirectory' });
          popup.classList.add('hidden');
          
        } catch(err) {
          console.error('Node creation error:', err, 'Cypher:', cypher);
          alert('Error creating node: ' + err.message);
        }
      };
    });
    // vulnerability marker
    addVulnMenu(nodeId);
  }

  // Handle edge right-click menu
  if(edgeId){
    const edge = edges.get(edgeId);
    if(edge){
      addMenuItem("Delete Edge", async () => {
        try {
          const res = await fetch("/api/delete-edge", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              start_id: edge.from,
              end_id: edge.to,
              rel_type: edge.label
            })
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          if (data.error) throw new Error(data.error);
          // Remove edge from visualization
          edges.remove(edgeId);
          console.log('Edge deleted successfully');
        } catch (err) {
          console.error('Delete edge error:', err);
          alert('Error deleting edge: ' + err.message);
        }
      });
    }
  }

  // if nothing was clicked, don't show menu
  if(menu.innerHTML.trim() === "") return;

  menu.style.left = x + "px";
  menu.style.top = y + "px";
  menu.style.display = "block";
}

// Menu Helpers
function addMenuItem(text, handler){
  const div = document.createElement("div");
  div.textContent = text;
  div.style.padding = "6px";
  div.style.cursor = "pointer";
  div.style.color = "#cfe8ff";
  div.onmouseenter = ()=> div.style.background = "#112034";
  div.onmouseleave = ()=> div.style.background = "transparent";
  // STOP PROPAGATION so the same click that opens the popup doesn't bubble to the
  // window click listener and immediately close the popup.
  div.onclick = (e) => { e.stopPropagation(); menu.style.display = "none"; handler(); };
  menu.appendChild(div);
}

document.addEventListener("click", ()=> menu.style.display = "none");

async function executeCypherQuery(cypher, params = {}) {
  try {
    const res = await fetch("/api/execute-cypher", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query: cypher, params: params })
    });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const data = await res.json();
    if (data.error) {
      throw new Error(data.error);
    }
    
    return data;
  } catch (err) {
    console.error('Query execution error:', err, 'Cypher:', cypher);
    throw err;
  }
}

function getDescendants(rootId) {
  const toVisit = [rootId];
  const visited = new Set();

  while (toVisit.length > 0) {
    const current = toVisit.pop();
    if (visited.has(current)) continue;
    visited.add(current);

    // Find children (edges where current is the parent)
    edges.forEach(edge => {
      if (edge.from === current) {
        toVisit.push(edge.to);
      }
    });
  }

  return Array.from(visited);
}


/* ===================== RUN CYPHER QUERY ===================== */
document.getElementById("btn-run-query").onclick = async ()=>{
  try {
    let query = document.getElementById("cypher-box").value.trim();
    let domain = document.getElementById("param-domain").value.trim();
    let subdomain = document.getElementById("param-subdomain").value.trim();
    let path = document.getElementById("param-path").value.trim();

    const payload = { query, params:{} };
    if(subdomain) payload.params.subdomain = subdomain;
    if(path) payload.params.path = path;
    if(domain) payload.params.domain = domain;

    const res = await fetch("/api/graph", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body:JSON.stringify(payload)
    });

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }

    const data = await res.json();
    if (data.error) {
      throw new Error(data.error);
    }
    renderGraph(data);
  } catch (err) {
    console.error('Query execution error:', err);
    alert('Error running query: ' + err.message);
  }
};


/* ===================== PREDEFINED QUERIES ===================== */
document.getElementById("preset-queries").onchange = ()=>{
  document.getElementById("cypher-box").value =
    document.getElementById("preset-queries").value;
};

/* Fit graph */
document.getElementById("btn-fit").onclick = ()=> network?.fit();


/* ===================== UPLOAD FORM ===================== */
document.getElementById("upload-form").onsubmit = async (e)=>{
  e.preventDefault();
  const fd = new FormData();
  const files = document.getElementById("files").files;
  const url = document.getElementById("url").value;

  for (const f of files) fd.append("file", f);
  fd.append("url", url);

  const submitBtn = document.getElementById('upload-submit') || document.querySelector('#upload-form button[type=submit]');
  if(submitBtn) { submitBtn.disabled = true; submitBtn.textContent = 'Uploading...'; }
  try{
    const res = await fetch("/upload", { method:"POST", body:fd });
    const data = await res.json();
    document.getElementById("upload-feedback").textContent = JSON.stringify(data, null, 2);
  }catch(err){
    document.getElementById("upload-feedback").textContent = String(err);
  } finally {
    if(submitBtn) { submitBtn.disabled = false; submitBtn.textContent = 'Upload & Parse'; }
  }
};

// Theme toggle
document.getElementById('toggle-theme').onclick = ()=>{
  const b = document.body;
  if(b.classList.contains('light')){
    b.classList.remove('light');
    document.getElementById('toggle-theme').textContent = 'Light Mode';
    // Update graph node colors to light text
    options.nodes.font.color = "#e6eef8";
    options.edges.font.color = "#7aa7d7";
  } else {
    b.classList.add('light');
    document.getElementById('toggle-theme').textContent = 'Dark Mode';
    // Update graph node colors to dark text
    options.nodes.font.color = "#071022";
    options.edges.font.color = "#071022";
  }
  // Redraw the network with new colors
  if(network) {
    network.setOptions(options);
  }
}

// set initial toggle label based on current body class
document.getElementById('toggle-theme').textContent = document.body.classList.contains('light') ? 'Dark Mode' : 'Light Mode';
// Set initial graph colors based on theme
if(document.body.classList.contains('light')){
  options.nodes.font.color = "#071022";
  options.edges.font.color = "#071022";
}

// Export handler
document.getElementById('btn-export').onclick = async ()=>{
  const res = await fetch('/api/export');
  const data = await res.json();
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'neo4j-export.json';
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

// Side panel functions
function populateSidePanel(node){
  const el = document.getElementById('node-data');
  el.innerHTML = '';
  const props = node || {};
  
  // Build full URL if this is a path or subdomain node
  let fullUrl = null;
  if(node && (props.group === 'Path' || props.group === 'Subdomain')){
    if(props.group === 'Path'){
      // Full URL = domain + path
      fullUrl = (props.domain || '') + (props.path || '');
    } else if(props.group === 'Subdomain'){
      // Full URL = host (which is the subdomain label)
      fullUrl = props.label || props.host || '';
    }
  }
  
  // Add full URL row at the top if available
  if(fullUrl){
    const row = document.createElement('div');
    row.style.display='flex'; row.style.justifyContent='space-between'; row.style.gap='8px'; row.style.padding='4px 0';
    row.style.fontWeight='bold'; row.style.color='#9bd0ff';
    const left = document.createElement('div'); left.textContent = 'Full URL: ' + fullUrl;
    const copy = document.createElement('button'); copy.textContent='Copy'; copy.onclick = ()=>{navigator.clipboard.writeText(fullUrl)};
    row.appendChild(left); row.appendChild(copy);
    el.appendChild(row);
    // Add separator
    const sep = document.createElement('div'); sep.style.height='1px'; sep.style.background='#123248'; sep.style.margin='4px 0';
    el.appendChild(sep);
  }
  
  // Add other properties (skip internal fields)
  const skipFields = new Set(['scanned_host', 'id', 'group']); // Don't show these
  for(const k of Object.keys(props)){
    if(skipFields.has(k)) continue; // Skip this field
    const row = document.createElement('div');
    row.style.display='flex'; row.style.justifyContent='space-between'; row.style.gap='8px'; row.style.padding='4px 0';
    const left = document.createElement('div'); left.textContent = k + ': ' + String(props[k]);
    const copy = document.createElement('button'); copy.textContent='Copy'; copy.onclick = ()=>{navigator.clipboard.writeText(String(props[k]))};
    row.appendChild(left); row.appendChild(copy);
    el.appendChild(row);
  }
}

document.getElementById('btn-save-notes').onclick = async ()=>{
  try {
    const txt = document.getElementById('node-notes').value;
    const node = window._lastSelectedNodeId;
    if(!node) return alert('No node selected');
    const res = await fetch('/api/node-notes', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify({node_id: node, notes: txt})
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    alert('Saved');
  } catch (err) {
    console.error('Save notes error:', err);
    alert('Error saving notes: ' + err.message);
  }
}

// Add 'Mark Vulnerability' action to context menu when node present
const originalAddMenuItem = addMenuItem;
function addVulnMenu(nodeId){
  addMenuItem('Mark Vulnerability', async ()=>{
    try {
      const q = `MATCH (n) WHERE elementId(n) = "${nodeId}" SET n.vuln = true RETURN elementId(n) AS id, n`;
      await executeCypherQuery(q);
      // update visual node: append a skull emoji to label
      const n = nodes.get(nodeId);
      if(n && !n.label.includes('☠️')) {
        nodes.update({id: nodeId, label: (n.label || '') + ' ☠️'});
      }
    } catch(err) {
      console.error('Mark vulnerability error:', err);
      // Only show alert for actual errors (network, parsing), not for empty results
      if(err.message && !err.message.includes('No records')) {
        alert('Error marking vulnerability: ' + err.message);
      }
    }
  });
  addMenuItem('Unmark Vulnerability', async ()=>{
    try {
      const q = `MATCH (n) WHERE elementId(n) = "${nodeId}" SET n.vuln = false RETURN elementId(n) AS id, n`;
      await executeCypherQuery(q);
      // remove skull emoji from label
      const n = nodes.get(nodeId);
      if(n) {
        const newLabel = (n.label || '').replace(/\s*☠️\s*$/, '');
        nodes.update({id: nodeId, label: newLabel});
      }
    } catch(err) {
      console.error('Unmark vulnerability error:', err);
      // Only show alert for actual errors (network, parsing), not for empty results
      if(err.message && !err.message.includes('No records')) {
        alert('Error unmarking vulnerability: ' + err.message);
      }
    }
  });
}

// Function to display vulnerability badge if vuln property is true
function updateNodeLabelForVulnerability(nodeData, nodeId){
  if(nodeData && nodeData.vuln && !nodeData.label?.includes('☠️')){
    nodes.update({id: nodeId, label: (nodeData.label || '') + ' ☠️'});
  }
}

// Ensure side panel and selection update after graph render
const originalRender = renderGraph;
renderGraph = function(data){
  originalRender(data);
  // add click hook
  network.off && network.off('click');
  network.on('click', (params)=>{
    if(params.nodes && params.nodes.length){
      const nid = params.nodes[0];
      window._lastSelectedNodeId = nid;
      const node = nodes.get(nid) || {};
      document.getElementById('selection-info').textContent = JSON.stringify(node, null, 2);
      populateSidePanel(node);
      // load notes
      fetch('/api/node-tasks/' + nid).then(r=>r.json()).then(d=>{document.getElementById('node-notes').value = d.notes || ''});
    }
  });
}

// ===== TASKS TAB FUNCTIONS =====
let taskOperators = [];

async function loadOperators() {
  try {
    const res = await fetch("/api/users");
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    taskOperators = data.operators || [];
  } catch(err) {
    console.error("Error loading operators:", err);
    taskOperators = [];
  }
}

async function loadTasksTab() {
  try {
    await loadOperators();
    
    // Clear containers
    const operatorsList = document.getElementById("operators-list");
    const allList = document.getElementById("all-list");
    operatorsList.innerHTML = "";
    allList.innerHTML = "";
    
    // Load operator dropdowns
    for(const op of taskOperators) {
      const opContainer = document.createElement("div");
      opContainer.style.cssText = "border:1px solid #15324a; padding:1rem; border-radius:4px; margin-bottom:1rem;";
      
      const label = document.createElement("h4");
      label.textContent = op;
      label.style.margin = "0 0 0.5rem 0";
  opContainer.appendChild(label);
  // Mark this container with the operator name so lookup is deterministic
  opContainer.setAttribute('data-operator', op);
      
      // Unchecked section
  const uncheckedLabel = document.createElement("label");
  uncheckedLabel.textContent = "Unchecked Endpoints";
  uncheckedLabel.style.cssText = "display:block; margin-top:0.5rem; font-weight:bold; color:#9bd0ff;";
      
      const uncheckedList = document.createElement("div");
      uncheckedList.style.cssText = "border:1px solid #7aa7d7; padding:0.5rem; border-radius:4px; max-height:250px; overflow-y:auto; margin-bottom:1rem;";
  uncheckedList.setAttribute('data-role', 'unchecked-list');
      
      // Checked section
  const checkedLabel = document.createElement("label");
  checkedLabel.textContent = "Checked Endpoints";
  checkedLabel.style.cssText = "display:block; margin-top:0.5rem; font-weight:bold; color:#9bd0ff;";
      
      const checkedList = document.createElement("div");
      checkedList.style.cssText = "border:1px solid #7aa7d7; padding:0.5rem; border-radius:4px; max-height:250px; overflow-y:auto;";
  checkedList.setAttribute('data-role', 'checked-list');
      
      // Load both lists
      const loadLists = async () => {
        try {
          const res = await fetch(`/api/unchecked-endpoints?operator=${encodeURIComponent(op)}`);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          
          // Clear lists
          uncheckedList.innerHTML = "";
          checkedList.innerHTML = "";
          
          // Get all endpoints to find checked ones
          const checkedRes = await fetch(`/api/all-endpoints`);
          const checkedData = await checkedRes.json();
          const allEndpoints = checkedData.endpoints || [];
          
          // Find checked endpoints for this operator
          const checkedEndpoints = allEndpoints.filter(ep => {
            const tasks = window.tasksData || {};
            const taskInfo = tasks[ep.id] || {};
            const checkedBy = taskInfo.checked_by || {};
            return op in checkedBy;
          });
          
          // Display unchecked
          if(data.endpoints.length === 0) {
            uncheckedList.innerHTML = "<p style='color:#9bd0ff;'>✓ All checked!</p>";
          } else {
            data.endpoints.forEach(ep => {
              const item = document.createElement("div");
              item.setAttribute("data-endpoint-id", ep.id);
              item.setAttribute("data-endpoint-label", ep.label);
              item.style.cssText = "padding:0.5rem; border-bottom:1px solid #15324a; display:flex; justify-content:space-between; align-items:center; color:#9bd0ff;";
              item.innerHTML = `<span style="flex:1;">${ep.label}</span><button style="padding:0.25rem 0.5rem; font-size:0.8rem; white-space:nowrap;" onclick="event.stopPropagation(); markEndpointChecked('${ep.id}', '${op}'); return false;">Mark Done</button>`;
              uncheckedList.appendChild(item);
            });
          }
          
          // Display checked
          if(checkedEndpoints.length === 0) {
            checkedList.innerHTML = "<p style='color:#9bd0ff;'>None checked yet</p>";
          } else {
            checkedEndpoints.forEach(ep => {
              const item = document.createElement("div");
              item.setAttribute("data-endpoint-id", ep.id);
              item.setAttribute("data-endpoint-label", ep.label);
              item.style.cssText = "padding:0.5rem; border-bottom:1px solid #15324a; display:flex; justify-content:space-between; align-items:center; color:#9bd0ff;";
              item.innerHTML = `<span style="flex:1;">✓ ${ep.label}</span><button style="padding:0.25rem 0.5rem; font-size:0.8rem; white-space:nowrap;" onclick="event.stopPropagation(); unmarkEndpointChecked('${ep.id}', '${op}'); return false;">Undo</button>`;
              checkedList.appendChild(item);
            });
          }
        } catch(err) {
          console.error("Error loading operator lists:", err);
          uncheckedList.innerHTML = `<p style='color:#ff6b6b;'>Error: ${err.message}</p>`;
        }
      };
      
      // Load on tab open
      await loadLists();
      
      opContainer.appendChild(uncheckedLabel);
      opContainer.appendChild(uncheckedList);
      opContainer.appendChild(checkedLabel);
      opContainer.appendChild(checkedList);
      operatorsList.appendChild(opContainer);
    }
    
    // Load "All unchecked" button
    const allBtn = document.getElementById("btn-expand-all");
    allBtn.onclick = async () => {
      try {
        const res = await fetch(`/api/unchecked-endpoints?operator=all`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        allList.innerHTML = "";
        if(data.endpoints.length === 0) {
          allList.innerHTML = "<p style='color:#9bd0ff;'>✓ All endpoints checked by someone!</p>";
        } else {
          data.endpoints.forEach(ep => {
            const item = document.createElement("div");
            item.style.cssText = "padding:0.5rem; border-bottom:1px solid #15324a; color:#9bd0ff;";
            item.innerHTML = `<strong>${ep.label}</strong><br/><small>Type: ${ep.type}</small>`;
            allList.appendChild(item);
          });
        }
      } catch(err) {
        console.error("Error loading all unchecked:", err);
        alert("Error loading endpoints: " + err.message);
      }
    };
    
  } catch(err) {
    console.error("Error loading Tasks tab:", err);
  }
}

async function markEndpointChecked(nodeId, operator) {
  try {
    const res = await fetch(`/api/mark-checked`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ node_id: nodeId, operator })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    
    // Find the operator container deterministically (match attribute exactly)
    const operatorContainer = Array.from(document.querySelectorAll('[data-operator]')).find(el => el.getAttribute('data-operator') === operator);
    if (!operatorContainer) {
      console.error('Could not find operator container for', operator);
      return;
    }

    // Find and remove the item from unchecked list inside this operator container
    const uncheckedItem = operatorContainer.querySelector(`div[data-endpoint-id="${nodeId}"]`);
    if (!uncheckedItem) return;

    const epLabel = uncheckedItem.getAttribute("data-endpoint-label");
    
    // Find the checked list in this operator container by role
    const checkedList = operatorContainer.querySelector("[data-role='checked-list']");
    if (!checkedList) {
      console.error("Could not find checked list");
      return;
    }
    
    // Remove "None checked yet" message if present
    const noneMsg = checkedList.querySelector("p");
    if (noneMsg && noneMsg.textContent === "None checked yet") {
      noneMsg.remove();
    }
    
    // Create new checked item
    const newItem = document.createElement("div");
    newItem.setAttribute("data-endpoint-id", nodeId);
    newItem.setAttribute("data-endpoint-label", epLabel);
    newItem.style.cssText = "padding:0.5rem; border-bottom:1px solid #15324a; display:flex; justify-content:space-between; align-items:center; color:#9bd0ff;";
    newItem.innerHTML = `<span style="flex:1;">✓ ${epLabel}</span><button style="padding:0.25rem 0.5rem; font-size:0.8rem; white-space:nowrap;" onclick="event.stopPropagation(); unmarkEndpointChecked('${nodeId}', '${operator}'); return false;">Undo</button>`;
    checkedList.appendChild(newItem);
    
    // Remove from unchecked list
    uncheckedItem.remove();
    
    // Check if unchecked list is now empty and show placeholder
    const uncheckedListEl = operatorContainer.querySelector("[data-role='unchecked-list']");
    if (uncheckedListEl && uncheckedListEl.children.length === 0) {
      uncheckedListEl.innerHTML = "<p style='color:#9bd0ff;'>✓ All checked!</p>";
    }
    
  } catch(err) {
    console.error("Error marking checked:", err);
    alert("Error marking endpoint: " + err.message);
  }
}

async function unmarkEndpointChecked(nodeId, operator) {
  try {
    const res = await fetch(`/api/mark-checked`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ node_id: nodeId, operator, checked: false })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    
    // Find the operator container deterministically (match attribute exactly)
    const operatorContainer = Array.from(document.querySelectorAll('[data-operator]')).find(el => el.getAttribute('data-operator') === operator);
    if (!operatorContainer) {
      console.error('Could not find operator container for', operator);
      return;
    }

    // Find and remove the item from checked list inside this operator container
    const checkedItem = operatorContainer.querySelector(`div[data-endpoint-id="${nodeId}"]`);
    if (!checkedItem) return;

    const epLabel = checkedItem.getAttribute("data-endpoint-label");
    
    // Find the unchecked list in this operator container by role
    const uncheckedList = operatorContainer.querySelector("[data-role='unchecked-list']");
    if (!uncheckedList) {
      console.error("Could not find unchecked list");
      return;
    }
    
    // Remove "All checked!" message if present
    const allCheckedMsg = uncheckedList.querySelector("p");
    if (allCheckedMsg && allCheckedMsg.textContent === "✓ All checked!") {
      allCheckedMsg.remove();
    }
    
    // Create new unchecked item
    const newItem = document.createElement("div");
    newItem.setAttribute("data-endpoint-id", nodeId);
    newItem.setAttribute("data-endpoint-label", epLabel);
    newItem.style.cssText = "padding:0.5rem; border-bottom:1px solid #15324a; display:flex; justify-content:space-between; align-items:center; color:#9bd0ff;";
    newItem.innerHTML = `<span style="flex:1;">${epLabel}</span><button style="padding:0.25rem 0.5rem; font-size:0.8rem; white-space:nowrap;" onclick="event.stopPropagation(); markEndpointChecked('${nodeId}', '${operator}'); return false;">Mark Done</button>`;
    uncheckedList.appendChild(newItem);
    
    // Remove from checked list
    checkedItem.remove();
    
    // Check if checked list is now empty and show placeholder
    const checkedListEl = operatorContainer.querySelector("[data-role='checked-list']");
    if (checkedListEl && checkedListEl.children.length === 0) {
      checkedListEl.innerHTML = "<p style='color:#9bd0ff;'>None checked yet</p>";
    }
    
  } catch(err) {
    console.error("Error unmarking checked:", err);
    alert("Error unmarking endpoint: " + err.message);
  }
}
</script>


</body>
</html>